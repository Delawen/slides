<!DOCTYPE html>
<html lang="es">
    <head>
      <meta charset="utf-8"/>
      <title>Introducción a los Patrones de Diseño</title>
      <meta name="author" content="María Arias de Reyna Domínguez"/>
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
      <link rel="stylesheet" href="../../reveal/css/reveal.css"/>
      <link rel="stylesheet" href="../../stylesheets/common.css"/>
      <link rel="stylesheet" href="../../stylesheets/redhat.css" id="theme"/>
    </head>


<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <section data-background-image="imagenes/cat_writing.webp">
          <article>
            <h1>Introducción a los Patrones de Diseño</h1>
            <br/>
            <h4>María Arias de Reyna</h4>
            <h6><a href="https://twitter.com/delawen">@delawen</a></h6>
            <h6>Senior Software Engineer at <a href="https://www.redhat.com"><svg style="height:40px"  title="RedHat" id="bff6975a-7895-41ba-961f-0551f01536a3" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 611.84 144"><defs><style>.b185c6fe-daea-408b-9fe9-61f9c6069fbe{fill:#e00;}</style></defs><title>RedHat</title><path class="b185c6fe-daea-408b-9fe9-61f9c6069fbe" d="M127.47,83.49c12.51,0,30.61-2.58,30.61-17.46a14,14,0,0,0-.31-3.42l-7.45-32.36c-1.72-7.12-3.23-10.35-15.73-16.6C124.89,8.69,103.76.5,97.51.5,91.69.5,90,8,83.06,8,76.38,8,71.42,2.4,65.17,2.4c-6,0-9.91,4.09-12.93,12.5,0,0-8.41,23.72-9.49,27.16A6.36,6.36,0,0,0,42.53,44c0,9.22,36.3,39.45,84.94,39.45M160,72.07c1.73,8.19,1.73,9.05,1.73,10.13,0,14-15.74,21.77-36.43,21.77C78.54,104,37.58,76.6,37.58,58.49a18.46,18.46,0,0,1,1.51-7.33C22.27,52,.5,55,.5,74.22c0,31.48,74.59,70.28,133.65,70.28,45.28,0,56.7-20.48,56.7-36.65,0-12.72-11-27.16-30.83-35.78" transform="translate(-0.5 -0.5)"></path><path d="M160,72.07c1.73,8.19,1.73,9.05,1.73,10.13,0,14-15.74,21.77-36.43,21.77C78.54,104,37.58,76.6,37.58,58.49a18.46,18.46,0,0,1,1.51-7.33l3.66-9.06a6.42,6.42,0,0,0-.22,1.9c0,9.22,36.3,39.45,84.94,39.45,12.51,0,30.61-2.58,30.61-17.46a14,14,0,0,0-.31-3.42Z" transform="translate(-0.5 -0.5)"></path></svg></a></h6>
          </article>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_glasses.webp">
          <article class="fragment">
            <img src="imagenes/Bubble-sort-example-300px.webp"/>
            <img src="imagenes/Insertion-sort-example-300px.webp"/>
          </article>
          <aside class="notes">
	        Vamos al lío. Mencionar la algoritmia (algoritmos de búsqueda como burbuja, árboles o inserción) y contar que esto es un paso más en la abstracción del diseño.
          </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_hammer.webp">
	        <aside class="notes">
		        Hay decenas (o centenas) de patrones diferentes. Hay que aprender bien los patrones porque si no, una vez que tienes un martillo, todo parecen clavos. Es más, un patrón al aplicado podría considerarse un antipatrón.
	        </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_glasses_off.webp">
	        <aside class="notes">
		        Hablemos ahora de los antipatrones. Nota: también hay antipatrones para la gestión de proyectos.
	        </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_antipattern.webp">
          <article>
            <h3>Cargo Cult Programming</h3>
          </article>
	        <aside class="notes">
		        Using patterns and methods without understanding why.<a href="https://en.wikipedia.org/wiki/Cargo_cult_programming">Cargo Cult Programming</a>
	        </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_spaguetti.webp">
          <article>
            <h3>Spaghetti code</h3>
          </article>
	        <aside class="notes">
		        Programs whose structure is barely comprehensible, especially because of misuse of code structures. Spaghetti code is a pejorative phrase for unstructured and difficult-to-maintain source code. Spaghetti code can be caused by several factors, such as volatile project requirements, lack of programming style rules, and insufficient ability or experience.[1]. Copy paste de Stack Overflow.
<a href="https://en.wikipedia.org/wiki/Spaghetti_code">Spaghetti Code</a>
	        </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_orgy.webp">
          <article>
            <h3>Object Orgy</h3>
          </article>
	        <aside class="notes">
		         In an object orgy, objects are insufficiently encapsulated via information hiding, allowing unrestricted access to their internals, usually leading to increased maintenance needs and problems, and even unmaintainable complexity.<a href="https://en.wikipedia.org/wiki/Object_orgy">Object Orgy</a>
	        </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/fat_cat.webp">
          <article>
            <h3>God Object</h3>
          </article>
	        <aside class="notes">
		         Concentrating too many functions in a single part of the design. <a href="https://en.wikipedia.org/wiki/God_object">God Object</a>
	        </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_aerobic.webp">
          <article>
            <h3>Busy Waiting</h3>
          </article>
	        <aside class="notes">
		        Consuming CPU while waiting for something to happen, usually by repeated checking instead of messaging.<a href="https://en.wikipedia.org/wiki/Busy_waiting">Busy Waiting</a>
	        </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_aerobic.webp">
          <article>
            <pre>
              <code class="hljs" data-line-numbers>
  public class Demo {
    public static void main(String[] args) {
      
      boolean eventHappened = false;

      while(!eventHappened) {
        Thread.sleep(1000); //duerme 1 segundo
        eventHappened = //¿seguimos esperando?
      }

      //¡ya podemos seguir la ejecución!
    }
  }
              </code>
            </pre>
          </article>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_ninja.webp">
          <article>
            <h3>Observer Pattern</h3>
          </article>
	        <aside class="notes">
		        The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer Pattern</a>
	        </aside>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_ninja.webp">
          <article>
            <pre>
              <code class="hljs" data-line-numbers>
  public class Demo {
    public static void main(String[] args) {
      EventManager eventManager = new EventManager();
        
      Listener l1 = new Listener() {
        public void trigger(Event event) {
          //hacer algo con el evento
        }
      };
      Listener l2 = new Listener() {
        public void trigger(Event event) {
          //hacer algo con el evento
        }
      };
      eventManager.addObserver(l1);
      eventManager.addObserver(l2);

      //pasa algo que genera un objeto Evento e1

      eventManager.notifyObservers(e1);
    }
  }
              </code>
            </pre>
          </article>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_ninja.webp">
          <article>
            <pre>
              <code class="hljs" data-line-numbers>
  public class Event {
    //objeto para contener información útil del evento 
    private String message;

    //Los atributos se suelen inicializar en el constructor
    public Event(String message) {
      this.message = message;
    }

    //getters
    public String getMessage() {
      return this.message;
    }
  }
              </code>
            </pre>
          </article>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_ninja.webp">
          <article>
            <pre>
              <code class="hljs" data-line-numbers>
  //Objetos interesados en eventos de este tipo
  //Uso el nombre "Listener" porque mucha gente
  //llama a este patrón Event-Listener
  public interface Listener {
    public void trigger(Event event);
  }
              </code>
            </pre>
          </article>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_ninja.webp">
          <article>
            <pre>
              <code class="hljs" data-line-numbers>
  //Gestor de Eventos
  public class EventManager {
    //a quién hay que notificar
    private final List&lt;Listener> observers = new ArrayList&lt;Listener>();
  
    //añadir observador a la lista
    public void addObserver(Listener observer) {
      observers.add(observer);
    }
  
    //función a la que llamará el creador del evento
    public void notifyObservers(String event) {
      observers.forEach(Listener::trigger);
    }
  }
              </code>
            </pre>
          </article>
        </section>
        <section data-background-size="contain" data-background-image="imagenes/cat_ninja.webp">
          <article>
            <pre>
              <code class="hljs" data-line-numbers>
  public class Demo {
    public static void main(String[] args) {
      EventManager eventManager = new EventManager();
        
      Listener l1 = new Listener() {
        public void trigger(Event event) {
          //hacer algo con el evento
        }
      };
      Listener l2 = new Listener() {
        public void trigger(Event event) {
          //hacer algo con el evento
        }
      };
      eventManager.addObserver(l1);
      eventManager.addObserver(l2);

      //pasa algo que genera un objeto Evento e1

      eventManager.notifyObservers(e1);
    }
  }
              </code>
            </pre>
          </article>
        </section>
        <section data-background-image="imagenes/cat_wrong.webp">
          <article>
            <h2>Preguntas</h2>
            <p>Esta presentación está en <span class="autofill-url"></span></p>
          </article>
        </section>
      </section>
    </div>
  </div>
  <script src="../../reveal/js/reveal.js"></script> 
  <script>
         // Full list of configuration options available here:
         // https://github.com/hakimel/reveal.js#configuration
         Reveal.initialize({
            controls: true,
            controlsBackArrows: 'faded',
            progress: true,
            history: true,
            keyboard: true,
            center: true,
            touch: true,
            hideAddressBar: true,
            transition: 'slide',
            width: '100%',
            height: '100%',
            margin: 0,
            minScale: 1,
            maxScale: 1,
            
            // Optional libraries used to extend on reveal.js
            dependencies: [
               { src: '../../reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				      	{ src: '../../reveal/plugin/highlight/highlight.js', async: true },
               { src: '../../reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
            ]
         });

  </script>
  <script>
    function fillUrl() {
      var i;
      var urls = document.getElementsByClassName("autofill-url");
      for (i = 0; i < urls.length; i++) {
        urls[i].innerHTML = window.location.origin + window.location.pathname;
      }
    }
    
    fillUrl(); 
  </script>
</body>
</HTML>
